Zasada dziaÅ‚ania: Strona jako "Dyrygent" ğŸµ
Strona (.astro) jest gÅ‚Ã³wnym dyrygentem na serwerze. To ona decyduje, jakie dane sÄ… potrzebne dla niej i dla wszystkich jej wysp.

Tworzy jednÄ… instancjÄ™ QueryClient na czas tego Å¼Ä…dania (per-request).

Pobiera wszystkie potrzebne dane.

Pakuje je w jeden obiekt (dehydratedState).

Przekazuje ten sam pakiet danych do MainLayout oraz do kaÅ¼dej wyspy z osobna.

W przeglÄ…darce, kaÅ¼da wyspa uÅ¼ywa helpera getQueryClient, aby uzyskaÄ‡ dostÄ™p do jednego, globalnego klienta (singletona) i wlewa do niego otrzymane dane.

Struktura plikÃ³w
Oto jak mogÅ‚aby wyglÄ…daÄ‡ Twoja struktura:

src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ CampaignDetails.tsx      # Wyspa - szczegÃ³Å‚y kampanii
â”‚   â”œâ”€â”€ PlayerCharacters.tsx     # Wyspa - postacie graczy
â”‚   â””â”€â”€ Monsters.tsx             # Wyspa - potwory
â”œâ”€â”€ layouts/
â”‚   â””â”€â”€ MainLayout.astro         # GÅ‚Ã³wny layout (szablon)
â”œâ”€â”€ lib/
â”‚   â””â”€â”€ queryClient.ts           # Nasz kluczowy helper
â””â”€â”€ pages/
    â””â”€â”€ campaigns/
        â””â”€â”€ [id].astro           # Strona-dyrygent dla konkretnej kampanii
Krok po kroku: Implementacja
1. Helper queryClient.ts (bez zmian)
Ten plik jest naszym fundamentem.

src/lib/queryClient.ts

TypeScript

import { QueryClient } from '@tanstack/react-query';

let browserQueryClient: QueryClient | undefined = undefined;

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: { retry: false, staleTime: 1000 * 60 * 5 },
    },
  });
}

export function getQueryClient() {
  if (import.meta.env.SSR) {
    return makeQueryClient(); // Zawsze nowa instancja na serwerze
  } else {
    if (!browserQueryClient) {
      browserQueryClient = makeQueryClient(); // Singleton w przeglÄ…darce
    }
    return browserQueryClient;
  }
}
2. Strona-Dyrygent: [id].astro
To jest serce naszej logiki po stronie serwera.

src/pages/campaigns/[id].astro

Fragment kodu

---
import { dehydrate } from '@tanstack/react-query';
import { getQueryClient } from '../../lib/queryClient';
import MainLayout from '../../layouts/MainLayout.astro';
import CampaignDetails from '../../components/CampaignDetails.tsx';
import PlayerCharacters from '../../components/PlayerCharacters.tsx';
import Monsters from '../../components/Monsters.tsx';

const { id } = Astro.params;

// 1. StwÃ³rz tymczasowy QueryClient dla tego Å¼Ä…dania
const queryClient = getQueryClient();

// 2. Pobierz WSZYSTKIE dane potrzebne dla tej strony i jej wysp
await Promise.all([
  queryClient.prefetchQuery({
    queryKey: ['campaign', id],
    queryFn: () => fetch(`https://api.example.com/campaigns/${id}`).then(res => res.json()),
  }),
  queryClient.prefetchQuery({
    queryKey: ['characters', { campaignId: id }],
    queryFn: () => fetch(`https://api.example.com/campaigns/${id}/characters`).then(res => res.json()),
  }),
  queryClient.prefetchQuery({
    queryKey: ['monsters', { campaignId: id }],
    queryFn: () => fetch(`https://api.example.com/campaigns/${id}/monsters`).then(res => res.json()),
  }),
]);

// 3. Spakuj wszystkie dane do jednego obiektu
const dehydratedState = dehydrate(queryClient);
queryClient.clear(); // PosprzÄ…taj po sobie na serwerze

const campaign = await queryClient.getQueryData(['campaign', id]);
---

<MainLayout title={campaign.name} dehydratedState={dehydratedState}>
  <CampaignDetails client:load dehydratedState={dehydratedState} campaignId={id} />
  <PlayerCharacters client:visible dehydratedState={dehydratedState} campaignId={id} />
  <Monsters client:idle dehydratedState={dehydratedState} campaignId={id} />
</MainLayout>
3. Layout i Wyspy (konsumenci danych)
Layout po prostu przekazuje dane dalej i renderuje slot.

src/layouts/MainLayout.astro

Fragment kodu

---
const { title, dehydratedState } = Astro.props;
---
<html>
  <head><title>{title}</title></head>
  <body>
    <header>Moja Apka D&D</header>
    <main>
      <slot />
    </main>
  </body>
</html>
KaÅ¼da wyspa jest zbudowana w ten sam sposÃ³b.

src/components/PlayerCharacters.tsx

TypeScript

import React, { useState } from 'react';
import { QueryClientProvider, HydrationBoundary, useQuery } from '@tanstack/react-query';
import { getQueryClient } from '../lib/queryClient';

// Komponent wyÅ›wietlajÄ…cy dane
function CharacterList({ campaignId }) {
  // Ten klucz MUSI byÄ‡ identyczny z tym uÅ¼ytym w `prefetchQuery`
  const { data, isLoading } = useQuery({
    queryKey: ['characters', { campaignId }]
  });

  if (isLoading) return <div>Åadowanie postaci...</div>;
  return (
    <section>
      <h2>Postacie Graczy</h2>
      <ul>{data?.map(char => <li key={char.id}>{char.name}</li>)}</ul>
    </section>
  );
}

// Wrapper do hydracji
export default function PlayerCharacters({ dehydratedState, campaignId }) {
  // Pobiera klienckiego singletona
  const [queryClient] = useState(() => getQueryClient());

  return (
    <QueryClientProvider client={queryClient}>
      <HydrationBoundary state={dehydratedState}>
        <CharacterList campaignId={campaignId} />
      </HydrationBoundary>
    </QueryClientProvider>
  );
}
Komponenty CampaignDetails.tsx i Monsters.tsx wyglÄ…daÅ‚yby analogicznie, uÅ¼ywajÄ…c swoich odpowiednich kluczy z useQuery.

Odpowiedzi na Twoje kluczowe pytania
Gdzie bÄ™dzie jeden queryClient po stronie klienta?
W module queryClient.ts.
Zmienna browserQueryClient jest singletonem. Mimo Å¼e kaÅ¼da wyspa (PlayerCharacters, Monsters) wywoÅ‚uje getQueryClient(), logika wewnÄ…trz tego pliku sprawia, Å¼e instancja jest tworzona tylko raz przy pierwszym wywoÅ‚aniu w przeglÄ…darce. Wszystkie kolejne wywoÅ‚ania zwracajÄ… tÄ™ samÄ…, juÅ¼ istniejÄ…cÄ… instancjÄ™.

Jak wyglÄ…da struktura po stronie serwera?
UÅ¼ytkownik wchodzi na /campaigns/123.

Astro uruchamia plik src/pages/campaigns/[id].astro.

Ten plik tworzy nowÄ…, tymczasowÄ… instancjÄ™ QueryClient tylko na potrzeby tego jednego Å¼Ä…dania.

Pobiera dane kampanii, postaci i potworÃ³w, zapeÅ‚niajÄ…c cache tego tymczasowego klienta.

Serializuje cache do obiektu dehydratedState.

Renderuje HTML, wstrzykujÄ…c dehydratedState jako prop do komponentÃ³w-wysp.

WysyÅ‚a gotowy HTML do przeglÄ…darki i niszczy tymczasowÄ… instancjÄ™ QueryClient.